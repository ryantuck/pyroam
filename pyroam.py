"""
PyRoam

Simple python interface for Roam Research graphs.

USAGE:

g = Graph('~/my_roam_graph_export.json')

NOTES:
- i'm calling 'pages' blocks for simplicity's sake, though subclassing would likely be cleaner.
- title is the id for 'pages'
- uid is the id for blocks
- a graph is the single object entrypoint, and blocks are stored in the hierarchy from there.

TODO:
x parse [[bracket references]] and #tags and ((block refs))
x fix the goddamn block repr
- ref to parent block id
- cli interface with queries, filters, etc.
- get typing right
- more meaningful diffs between pages and blocks
- add tests!
    - regex
    - sample graph
- add support for unlinked references
- add support for networkx representation
- more fully-featured search

"""
from dataclasses import dataclass
from typing import List
import json
import os
import re


TAG_REGEX = r"\s+#([A-Za-z0-9-]*)"  # NOTE: doesn't support tags with spaces
BRACKETS_REGEX = r"\[\[([A-Za-z0-9- ]*)\]\]"
PARENS_REGEX = r"\(\(([A-Za-z0-9- ]*)\)\)"


@dataclass
class Block:

    _title: str
    _children: List["Block"]  # 'Forward reference' support for recursion a la PEP 484
    _uid: str
    _string: str

    # TODO: make these datetimes
    _edit_time: str
    _edit_email: str
    _create_time: str
    _create_email: str
    _heading: str  # NOTE: not sure what this is

    def __post_init__(self):

        # sanity checks
        if self._title and self._string:
            raise Exception("title and string expected mutually exclusive")
        if self._title and self._uid:
            raise Exception("title and uid expected mutually exclusive")

    def __repr__(self):
        return f'{self.type()} | {self.id()} | c{len(self.children())}d{len(self.descendants())} | {self.text()}'

    def type(self):
        return "NOTE" if self._uid is None else "BLOCK"

    def text(self):
        return self._title or self._string

    def id(self):
        return self._title or self._uid

    def _id_references(self):

        return sorted(
            set(
                match
                for regex in [TAG_REGEX, BRACKETS_REGEX, PARENS_REGEX]
                for match in re.findall(regex, self.text())
            )
        )

    def _child_id_references(self):
        return sorted(
            set(match for child in self.children() for match in child._id_references())
        )

    def _descendant_id_references(self):
        return sorted(
            set(ref for b in self.descendants() for ref in b._id_references())
        )

    def references(self, graph: 'Graph'):
        """
        Returns blocks referenced by this block. Does not include descendant references.
        """
        return [graph.get_block(ref_id) for ref_id in self._id_references()]

    def linked_references(self, graph):
        """
        Return all blocks that reference this block.
        """
        return [b for b in graph.all_blocks() if self in b.references(graph)]

    def children(self):
        return self._children

    def descendants(self):
        return self.children() + [cb for child in self.children() for cb in child.children()]


@dataclass
class Graph:

    filepath: str

    def __post_init__(self):
        self._data = read_graph_json_file(self.filepath)
        self.blocks = [get_block(b) for b in self._data]

        # sanity checks
        all_blocks = self.all_blocks()
        if len(all_blocks) != len(set(b.id() for b in all_blocks)):
            raise Exception('All block ids should be unique')

    def __repr__(self):
        return f'Graph | {self.filepath} | Pages: {len(self.blocks)} | Blocks: {len(self.all_blocks())}'

    def all_blocks(self):
        """
        Returns list of every Block.
        """
        return self.blocks + [db for b in self.blocks for db in b.descendants()]

    def get_block(self, block_id):
        """
        Returns Block with given `block_id`.
        """
        try:
            return next(b for b in self.all_blocks() if b.id() == block_id)
        except StopIteration:
            # handling this error case for bad regex matching and garbage css generated by Roam
            # code blocks. Tighten up the regex and we can remove this hack.
            print(f"Couldn't find block with id: '{block_id}'")
            return None

    def search(self, query):
        """
        Rudimentary search for blocks containing `query` in their `text` or `id`.
        """
        return [b for b in self.all_blocks() if query in b.text() or query in b.id()]


def read_graph_json_file(filepath):
    user_fp = os.path.expanduser(filepath)
    with open(user_fp) as f:
        return json.load(f)


def get_block(b: dict):
    """
    Return a Block object from its JSON representation.
    """
    return Block(
        _title=b.get("title"),
        _uid=b.get("uid"),
        _children=[get_block(c) for c in b.get("children", [])],
        _string=b.get("string"),
        _edit_time=b.get("edit-time"),
        _edit_email=b.get("edit-email"),
        _create_time=b.get("create-time"),
        _create_email=b.get("create-email"),
        _heading=b.get("heading"),
    )


def get_graph(filepath):
    return Graph(filepath)


def main():
    g = get_graph('~/Downloads/graph.json')


if __name__ == "__main__":
    main()
